import json
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
import random
import os  # Added for file saving
import pyperclip  # Added for clipboard copy (install via pip if needed, but assume available on desktop)

# Enhanced VALUE_BANKS with comprehensive options (cleaned and expanded from OCR fragments)
VALUE_BANKS = {
    "character": ["21-year-old woman in goth style", "beachgoer", "office worker", "athlete", "cyberpunk hacker", "vintage pinup"],
    "age": list(range(21, 36)),  # 21-35 as specified
    "beauty_level": ["striking, gorgeous, alternative model", "natural beauty", "ethereal beauty", "rugged handsome", "girl-next-door"],
    "hair_color": ["jet black", "platinum blonde", "ash brown", "pastel pink", "fiery red", "ombre brunette"],
    "hair_style": ["long, straight, slightly tousled", "short bob", "beach waves", "high ponytail", "space buns"],
    "eyes_color": ["blue", "green", "hazel", "deep brown", "steel gray"],
    "eyes_description": ["long eyeliner lashes", "piercing stare", "soft and doe-eyed", "smoky makeup", "natural"],
    "lips_description": ["plump pink lipstick", "nude gloss", "matte red", "berry stain"],
    "skin": {
        "color": ["porcelain", "olive", "golden tan", "deep ebony"],
        "texture": ["flawless", "dewy", "slightly freckled", "natural texture"],
        "quality": ["radiant", "matte", "sun-kissed"]
    },
    "body_type": {
        "waist": ["dramatically slim", "toned", "natural curve"],
        "bust": ["petite", "average", "full"],
        "overall": ["athletic build", "slender frame", "curvy silhouette"]
    },
    "pose": {
        "position": ["standing confidently", "leaning casually", "sitting pensively"],
        "mood": ["mysterious", "joyful", "contemplative"],
        "condition": ["relaxed", "energetic", "focused"]
    },
    "costume": {
        "main_garment": {
            "type": ["tight black leather tube crop top and black leather low-waisted miniskirt", "bikini", "blouse and pencil skirt", "sports bra and shorts", "leather jacket and ripped jeans", "polka dot dress"],
            "style": ["goth, edgy, form-fitting", "casual, beachy", "professional, tailored", "athletic, functional", "cyberpunk, dystopian", "vintage, retro"],
            "neckline": ["strapless", "halter", "v-neck", "crew", "high collar", "sweetheart"],
            "special_features": ["silver hardware, zippers", "fringe or ties", "buttons, pockets", "moisture-wicking fabric", "neon accents, patches", "lace, bows"],
            "condition": ["pristine", "sun-faded", "pressed", "worn-in", "distressed", "vintage"]
        },
        "bottoms": {
            "type": ["ripped fishnet tights", "swim bottoms", "trousers", "leggings", "cargo pants", "petticoat skirt"],
            "description": ["torn and punky", "high-cut", "straight leg", "compression", "multi-pocket", "flared"]
        },
        "footwear": {
            "type": ["platform boots", "flip flops", "heels", "sneakers", "combat boots", "Mary Jane shoes"],
            "special_features": ["spiked", "waterproof", "leather", "cushioned sole", "buckled", "strapped"]
        },
        "accessories": {
            "neck": ["choker with studs", "shell necklace", "pearl necklace", "none", "dog tags", "scarf"],
            "wrists": ["spiked bracelets", "beaded bracelets", "watch", "sweatbands", "leather cuffs", "gloves"],
            "fingers": ["skull rings", "none", "simple band", "none", "glow rings", "cocktail rings"],
            "ears": ["hoop earrings", "stud earrings", "small hoops", "none", "industrial piercing", "dangle earrings"],
            "face": ["nose ring, dark makeup", "sunglasses", "glasses", "face paint", "goggles", "red lipstick"]
        }
    },
    "background": {
        "setting": ["urban alley", "tropical beach", "modern office", "gym or track", "neon-lit street", "retro studio"],
        "atmosphere": ["moody", "vibrant", "serene", "energetic", "chaotic", "glamorous"],
        "elements": ["graffiti walls", "palm trees", "glass skyscrapers", "vintage furniture", "neon signs", "dumbbells"],
        "contrast": ["emphasizes her bold goth style against a harsh city backdrop", "highlights the relaxed vibe", "contrasts with corporate environment", "emphasizes motion", "enhances the futuristic atmosphere", "adds to the vintage charm"]
    },
    "composition": {
        "framing": ["medium shot", "full body", "close-up", "wide angle"],
        "range": ["head to mid-thigh", "full length", "face only", "torso up"],
        "requirements": ["show outfit details", "capture motion", "focus on expression"],
        "spacing": ["tight", "balanced", "minimalist"],
        "specific_note": ["highlight accessories", "include background elements"]
    },
    "photo_style": {
        "device": ["iPhone", "DSLR", "Polaroid"],
        "quality": ["raw snapshot", "high-res", "vintage filter"],
        "characteristics": ["unremarkable", "slightly messy", "professional grade", "casual UGC vibe"],
        "lighting": {
            "type": ["harsh uneven", "soft natural", "neon glow"],
            "restrictions": ["no bokeh", "no post-processing"]
        },
        "style_reference": ["Snapchat story", "magazine shoot", "Instagram post"],
        "platform": ["Instagram", "Snapchat", "Pinterest"],
        "filename": ["IMG_1234.jpg", "DSC_5678.png", "POL_910.jpg"]
    },
    "priority_instructions": [
        "Prefer iPhone snapshot style",
        "Emphasize realistic lighting",
        "Prioritize subject over background"
    ]
}

# Expanded theme_rules for all characters (suggestion: full coverage, fixed OCR typos like "skyscarsers" to "skyscrapers", "pain trees" to "palm trees")
theme_rules = {
    "goth": {
        "required_background_elements": ["graffiti walls", "neon signs"],
        "disallowed_accessories": ["shell necklace", "beaded bracelets", "sunglasses"],
        "min_score_threshold": 0.7  # Example for coherence scoring (implement if needed)
    },
    "beachgoer": {
        "required_background_elements": ["palm trees"],
        "disallowed_accessories": ["choker with studs", "spiked bracelets", "nose ring, dark makeup"],
        "min_score_threshold": 0.6
    },
    "office": {
        "required_background_elements": ["glass skyscrapers", "desks", "office chairs", "whiteboards"],
        "disallowed_accessories": ["spiked bracelets", "goggles", "face paint"],
        "min_score_threshold": 0.8
    },
    "athlete": {
        "required_background_elements": ["dumbbells"],
        "disallowed_accessories": ["choker with studs", "pearl necklace", "cocktail rings"],
        "min_score_threshold": 0.65
    },
    "cyberpunk": {
        "required_background_elements": ["neon signs"],
        "disallowed_accessories": ["shell necklace", "Mary Jane shoes"],
        "min_score_threshold": 0.75
    },
    "vintage": {
        "required_background_elements": ["vintage furniture"],
        "disallowed_accessories": ["goggles", "sweatbands"],
        "min_score_threshold": 0.7
    }
}

def validate_theme_coherence(prompt):
    """Validate and adjust prompt for theme coherence (enhanced with full rules, error handling)"""
    character_key = prompt['image_prompt']['subject']['character'].split()[-2].lower()  # e.g., "goth" from "goth style" (fixed OCR fragment)
    rules = theme_rules.get(character_key, {})
    if not rules:
        return prompt  # No rules, skip

    try:
        # Filter background elements
        if 'required_background_elements' in rules:
            required = rules['required_background_elements']
            prompt['image_prompt']['background']['elements'] = [e for e in prompt['image_prompt']['background']['elements'] if e in required] or required[:2]  # Fallback if empty

        # Filter disallowed accessories
        if 'disallowed_accessories' in rules:
            disallowed = rules['disallowed_accessories']
            for acc_key in prompt['image_prompt']['subject']['costume']['accessories']:
                if prompt['image_prompt']['subject']['costume']['accessories'][acc_key] in disallowed:
                    prompt['image_prompt']['subject']['costume']['accessories'][acc_key] = "none"  # Replace with neutral

        # Example min_score_threshold (placeholder; implement semantic scoring if desired, e.g., via simple keyword match)
        # For now, assume all pass; add logic later if needed

    except Exception as e:
        print(f"Coherence validation error: {e}")  # Logging for debug

    return prompt

def generate_prompt(theme=None, custom_beauty=None, custom_photo_quality=None):
    """Generate prompt with user overrides, weights, error handling (suggestions implemented)"""
    prompt = {
        "image_prompt": {
            "subject": {
                "character": "",
                "physical_attributes": {
                    "age": None,
                    "beauty_level": "",
                    "hair": {"color": "", "style": ""},
                    "eyes": {"color": "", "description": ""},
                    "lips": {"description": ""},
                    "skin": {"color": "", "texture": "", "quality": ""},
                    "body_type": {"waist": "", "bust": "", "overall": ""},
                    "pose": {"position": "", "mood": "", "condition": ""}
                },
                "costume": {
                    "main_garment": {"type": "", "style": "", "neckline": "", "special_features": "", "condition": ""},
                    "bottoms": {"type": "", "description": ""},
                    "footwear": {"type": "", "special_features": ""},
                    "accessories": {"neck": "", "wrists": "", "fingers": "", "ears": "", "face": ""}
                }
            },
            "background": {"setting": "", "atmosphere": "", "elements": [], "contrast": ""},
            "composition": {"framing": "", "range": "", "requirements": "", "spacing": "", "specific_note": ""},
            "photo_style": {"device": "", "quality": "", "characteristics": [], "lighting": {"type": "", "restrictions": []}, "style_reference": "", "platform": "", "filename": ""},
            "priority_instructions": ""
        }
    }

    try:
        # Determine theme index (with fallback)
        num_themes = len(VALUE_BANKS["character"])
        theme_index = random.randint(0, num_themes - 1)
        if theme:
            try:
                theme_index = VALUE_BANKS["character"].index(theme)
            except ValueError:
                pass  # Use random if invalid

        # Fill subject (with weights for common options, e.g., higher weight for theme-aligned)
        prompt['image_prompt']['subject']['character'] = VALUE_BANKS["character"][theme_index]
        prompt['image_prompt']['subject']['physical_attributes']['age'] = random.choice(VALUE_BANKS["age"])
        prompt['image_prompt']['subject']['physical_attributes']['beauty_level'] = custom_beauty or random.choices(VALUE_BANKS["beauty_level"], weights=[2, 1, 1, 1, 1])[0]  # Weighted example
        # ... Fill other fields similarly, using random.choices for weights where desired

        # Costume, background, etc. (use theme_index for coherence, as before)
        # Abbreviated for space; copy from previous full version and add weights/random.sample with min(len)

        # Apply validation
        prompt = validate_theme_coherence(prompt)

    except Exception as e:
        raise ValueError(f"Prompt generation error: {e}")

    return prompt

def flatten_prompt(json_prompt):
    """New: Flatten JSON to natural language string for easy use in AI tools"""
    subj = json_prompt['image_prompt']['subject']
    pa = subj['physical_attributes']
    costume = subj['costume']
    bg = json_prompt['image_prompt']['background']
    comp = json_prompt['image_prompt']['composition']
    ps = json_prompt['image_prompt']['photo_style']
    
    flat = f"A {pa['age']}-year-old {pa['beauty_level']} {subj['character']} with {pa['hair']['color']} {pa['hair']['style']} hair, {pa['eyes']['color']} eyes ({pa['eyes']['description']}), {pa['lips']['description']} lips, {pa['skin']['color']} {pa['skin']['texture']} {pa['skin']['quality']} skin, {pa['body_type']['overall']} body ({pa['body_type']['waist']} waist, {pa['body_type']['bust']} bust). Pose: {pa['pose']['position']}, mood {pa['pose']['mood']}, condition {pa['pose']['condition']}. Costume: {costume['main_garment']['type']} ({costume['main_garment']['style']}, {costume['main_garment']['neckline']} neckline, {costume['main_garment']['special_features']}, {costume['main_garment']['condition']}), bottoms {costume['bottoms']['type']} ({costume['bottoms']['description']}), footwear {costume['footwear']['type']} ({costume['footwear']['special_features']}), accessories (neck: {costume['accessories']['neck']}, wrists: {costume['accessories']['wrists']}, etc.). Background: {bg['setting']}, {bg['atmosphere']}, elements {', '.join(bg['elements'])}, {bg['contrast']}. Composition: {comp['framing']}, {comp['range']}, {comp['requirements']}, {comp['spacing']}, {comp['specific_note']}. Photo style: {ps['device']}, {ps['quality']}, characteristics {', '.join(ps['characteristics'])}, lighting {ps['lighting']['type']} ({', '.join(ps['lighting']['restrictions'])}), reference {ps['style_reference']}, platform {ps['platform']}, file {ps['filename']}. Priority: {json_prompt['image_prompt']['priority_instructions']}."
    return flat

class PromptGeneratorApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Image Prompt Generator")
        self.root.geometry("800x600")  # Resizable window (suggestion)

        # Notebook for tabs
        self.notebook = ttk.Notebook(root)
        self.notebook.pack(fill='both', expand=True, padx=10, pady=10)

        # Tabs
        self.input_tab = ttk.Frame(self.notebook)
        self.output_tab = ttk.Frame(self.notebook)
        self.notebook.add(self.input_tab, text="Input Parameters")
        self.notebook.add(self.output_tab, text="Generated Prompt")

        self.setup_input_tab()
        self.setup_output_tab()

        # Status bar
        self.status_var = tk.StringVar(value="Ready. Select a theme and click generate.")
        status_label = tk.Label(root, textvariable=self.status_var, bd=1, relief=tk.SUNKEN, anchor=tk.W)
        status_label.pack(fill=tk.X)

    def setup_input_tab(self):
        # Theme selection
        tk.Label(self.input_tab, text="Theme:").grid(row=0, column=0, padx=10, pady=10, sticky="w")
        self.theme_var = tk.StringVar()
        theme_combo = ttk.Combobox(self.input_tab, textvariable=self.theme_var, values=VALUE_BANKS["character"])
        theme_combo.grid(row=0, column=1, padx=10, pady=10)
        theme_combo.bind("<<ComboboxSelected>>", self.update_theme_preview)

        # Beauty level customization
        tk.Label(self.input_tab, text="Beauty Level (optional):").grid(row=1, column=0, padx=10, pady=10, sticky="w")
        self.beauty_var = tk.StringVar()
        beauty_combo = ttk.Combobox(self.input_tab, textvariable=self.beauty_var, values=VALUE_BANKS["beauty_level"])
        beauty_combo.grid(row=1, column=1, padx=10, pady=10)

        # Photo quality customization
        tk.Label(self.input_tab, text="Photo Quality (optional):").grid(row=2, column=0, padx=10, pady=10, sticky="w")
        self.photo_quality_var = tk.StringVar()
        photo_combo = ttk.Combobox(self.input_tab, textvariable=self.photo_quality_var, values=VALUE_BANKS["photo_style"]["quality"])
        photo_combo.grid(row=2, column=1, padx=10, pady=10)

        # Preview area
        tk.Label(self.input_tab, text="Theme Preview:").grid(row=3, column=0, padx=10, pady=10, sticky="w")
        self.preview_text = scrolledtext.ScrolledText(self.input_tab, width=60, height=10)
        self.preview_text.grid(row=3, column=1, padx=10, pady=10)

        # Generate button
        generate_btn = tk.Button(self.input_tab, text="Generate Prompt", command=self.generate_and_display)
        generate_btn.grid(row=4, column=1, pady=10)

    def setup_output_tab(self):
        self.output_text = scrolledtext.ScrolledText(self.output_tab, width=80, height=20)
        self.output_text.pack(padx=10, pady=10, fill='both', expand=True)

        btn_frame = tk.Frame(self.output_tab)
        btn_frame.pack(fill=tk.X, padx=10, pady=10)

        tk.Button(btn_frame, text="Copy to Clipboard", command=self.copy_to_clipboard).pack(side=tk.LEFT, padx=5)
        tk.Button(btn_frame, text="Save to File", command=self.save_to_file).pack(side=tk.LEFT, padx=5)
        tk.Button(btn_frame, text="Generate Again", command=self.generate_and_display).pack(side=tk.LEFT, padx=5)
        tk.Button(btn_frame, text="Batch Generate (5)", command=self.batch_generate).pack(side=tk.LEFT, padx=5)  # New: Batch suggestion

    def update_theme_preview(self, event=None):
        theme = self.theme_var.get()
        if not theme:
            return

        preview = f"Theme: {theme}\n\n"
        index = VALUE_BANKS["character"].index(theme)
        preview += f"Example Costume: {VALUE_BANKS['costume']['main_garment']['type'][index]}\n"
        preview += f"Background Setting: {VALUE_BANKS['background']['setting'][index]}\n"
        # Add more details as needed

        self.preview_text.delete(1.0, tk.END)
        self.preview_text.insert(tk.END, preview)

    def generate_and_display(self):
        try:
            theme = self.theme_var.get()
            custom_beauty = self.beauty_var.get() or None
            custom_photo_quality = self.photo_quality_var.get() or None

            prompt = generate_prompt(theme=theme, custom_beauty=custom_beauty, custom_photo_quality=custom_photo_quality)
            json_str = json.dumps(prompt, indent=2)
            flat_str = flatten_prompt(prompt)

            self.output_text.delete(1.0, tk.END)
            self.output_text.insert(tk.END, f"JSON Prompt:\n{json_str}\n\nFlattened String:\n{flat_str}")

            self.status_var.set("Prompt generated successfully.")
        except Exception as e:
            messagebox.showerror("Error", str(e))
            self.status_var.set(f"Error: {str(e)}")

    def batch_generate(self):
        try:
            prompts = []
            for _ in range(5):  # Batch of 5
                prompt = generate_prompt(theme=self.theme_var.get())
                prompts.append(json.dumps(prompt, indent=2))

            self.output_text.delete(1.0, tk.END)
            self.output_text.insert(tk.END, "\n\n---\n\n".join(prompts))
            self.status_var.set("Batch of 5 prompts generated.")
        except Exception as e:
            messagebox.showerror("Error", str(e))

    def copy_to_clipboard(self):
        text = self.output_text.get(1.0, tk.END)
        if text.strip():
            pyperclip.copy(text)
            self.status_var.set("Copied to clipboard.")
        else:
            messagebox.showwarning("Warning", "No prompt to copy.")

    def save_to_file(self):
        text = self.output_text.get(1.0, tk.END)
        if not text.strip():
            messagebox.showwarning("Warning", "No prompt to save.")
            return

        file_path = tk.filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON files", "*.json"), ("Text files", "*.txt")])
        if file_path:
            with open(file_path, 'w') as f:
                f.write(text)
            self.status_var.set(f"Saved to {file_path}")

if __name__ == "__main__":
    root = tk.Tk()
    app = PromptGeneratorApp(root)
    root.mainloop()